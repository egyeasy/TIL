# 190420 백준 특강 - 프로그래밍 대회

ACMICPC - 대학생 대회

facebook 해커잼(?), 구글 코드잼

프로그래밍 대회는 갈수록 난이도가 어려워지도 있다. 점점 공부할 게 많아짐

오늘은 대회에 나오는 것 중에서도 가장 쓰임새가 많고, 일을 할 때도 쓰임새가 한 번이라도 있는 것

=> 쿼리 문제



## 쿼리 문제

지금까지는 입력이 주어질 때 이런 방식으로 출력하라는 문제.

쿼리 문제는 문제에서 쿼리를 구해서 답을 구하기.

검색이 가장 대표적인 쿼리 문제. 

but 어려움. 일반 문제도 쿼리가 섞이면 어렵다.

미로 안에 직사각형에서 탈출하는 문제 -> 이것의 다른 버전을 풀어보기로 한다.



## RMQ

### 구간의 최소값 구하기(Range Minimum Query)

Range Minumum 문제 : 2 - 7 번째 중에 최소값을 구하라

query 문제 : i - j 번째 중에 최소값을 구하라. -> 이러한 연산이 총 M개 주어진다.

하나의 쿼리를 수행하는 데 O(N)이 걸린다고 하면 총 O(MN)이 걸림



## 루트N으로 나누기

### 시간복잡도의 계산

1. 선처리 preprocessing - 입력으로 주어진 데이터를 처리하기 쉽게 다듬는 과정
2. 쿼리 query

전체 시간복잡도 = 1. + 2. * M(쿼리 수)

선처리는 한번만 하고 2.를 M번 하기 때문에 쿼리의 시간복잡도를 줄이는 것이 핵심.



### 루트N으로 나누기(sqrt decomposition)

수가 N개 있으면 그룹을 지어줘서 루트N개의 그룹이 나오게 하려고 한다.

N = 11일 때 루트11 = 3이라고 하고 3개의 그룹으로 나눠보자.

그러면 루트N * 루트N = (그룹의 수) * (그룹의 크기)

각 그룹의 최소값을 구해서Group[i]의 i번 그룹의 최소값을 저장



### 선처리

```c++
for (int i=0; i<n; i++) {
  if (i%r == 0) {
    group[i/r] = a[i];
  }
  // 중략
}
```



최소값을 구하는 쿼리 i, j는 두 가지 경우가 있다.

1. i와 j가 같은 그룹인 경우
2. i와 j의 그룹이 다른 경우



1. i와 j가 같은 그룹인 경우

   i=1, j=2이고 1번도 0번 그룹, 2번도 0번 그룹에 속할 경우 0번이 최소값일 경우가 있으므로 그룹의 최소값을 이용할 수 없다. -> 해당 그룹의 수를 모두 비교(O(루트N) = 그룹의 크기)

   ```c++
   각각을 모두 비교
   for (int i=start; )
   ```

   

2. i와 j의 그룹이 다른 경우

   1) i=1, j=9이면 시작 그룹, 끝 그룹의 수는 각각 i번과 j번부터 다 비교해봐야 한다. O(루트N)

   2) 그 사이에 있는 애들은 항상 전체가 포함됨 -> 그룹 최소값 이용 가능. O(루트N)

   총 O(3 * 루트N)의 시간 복잡도가 걸리게 됨



### 비교

1. 하나씩 다 비교

   0(preprocessing) + N = M * N

2. 그룹 비교

   N(preprcessing) + 루트N = N + M * 루트N

근데 굳이 루트N으로 나눌 필요도 없다. 200이나 300 정도로 나눴을 때 더 빠를 수 있다. 쿼리가 어떻게 생겼냐에 따라 실제 걸리는 시간이 바뀌므로 그걸 바꿔서 통과하는 경우도 있을 수 있다.



## 세그먼트 트리(인덱스 트리) - 오늘 가장 중요! 이걸 할 줄 알아야 계산의 벽을 넘을 수 있음

목표 : 구간의 최소값을 구한다.

트리의 모든 노드는 s~e로 이뤄져있다. s는 시작 인덱스, e는 끝 인덱스

가장 루트 노드가 s~e 전체 중 최소값을 가지고 있음

m = (s + e) / 2

자식 -> s~m(절반) / m+1~e(나머지 절반) 중의 최소값을 가지고 있음

​		0~9

​	0~4	5~9

0~2. 3~4. 5~7. 8~9



일반 트리와 다르게 세그먼트 트리는 항상 루트가 있어야 하고, 저장하는 형식이 다르다.

항상 2분할 되고, 트리의 높이가 있는데 최하단 리프노드와 그 위의 리프노드는 항상 깊이가 1만 차이나게 된다.

이진 트리를 사용하게 됨.



### 이진 트리(Binary Tree)

full binary tree -> 꽉차있는 것. 가장 아래의 노드 빼고는 모두 자식이 두 개인 트리. 높이 h인 fbt = 2^h - 1개의 노드

complete binary tree -> 가장 아래 depth만 노드가 몇 개 없는 것. 배열을 써서 가장 효율적으로 정리할 수 있다. 순서대로 index를 채워갈 수 있으므로 배열에 저장. 부모가 x번째면 자식은 2x, 2x+1번째다. 힙(heap)도 이 방식을 사용하여 저장하게 됨.



### 세그먼트 트리

complete binary tree와 유사하게 배열을 이용해서 구현할 수 있다. (x - 2x, 2x+1)

왼쪽 자식은 항상 짝수, 오른쪽은 홀수라는 것이 특징.

한 노드에 (x, s, e)의 세 정수가 들어가게 됨 x: 저장 인덱스, s: 시작 인덱스, e: 끝 인덱스

0~2의 최소를 알고 있고, 3~4의 최소를 알고 있다면 0~4의 최소는 두 개의 값만 비교함으로써도 구할 수 있다.(bottom-up)

모든 노드의 최소값을 구하기 전에 왼쪽 절반의 최소값, 오른쪽 절반의 최소값을 구하면 됨

```c++
// 트리 배열, 입력 배열, 저장되는 인덱스, 스타트, 엔드 인덱스
void init(vector<int> &tree, vector<int> &a, int node, int start, int end)
if (start == end) { // 한 개 짜리라면 그대로 저장
  tree[node] = a[start];
} else {
  init(tree, a, node*2, start, (start+end)/2);
  init(tree, a, node*2+1, (start+end)/2+1, end);
  tree[node] = min(tree[node*2],tree[node*2+1]);
}
```

총 O(NlogN)의 시간복잡도. 앞에서 본 것보다 오래 걸림.

그 다음엔 진짜 구하려고 하는 최소값을 구해야 한다.



### 쿼리

0~9 최소값 : 루트의 최소값 구하면 됨

2~4 최소값 : 루트 -> 왼쪽(0~4)과 오른쪽(5~9) 중 왼쪽(오른쪽을 볼 때 -1을 리턴 / 왼쪽을 볼 때 담고 있는 범위가 구하는 범위보다 크므로 왼쪽/오른쪽으로 나눔) -> 왼쪽(0~2)과 오른쪽(3~4) 중 오른쪽은 범위가 구하는 범위에 포함하므로 값을 빼옴 / 0~2는 다시 분해해서 오른쪽(2) 값을 빼내와서 비교

양분되는 구간이 전혀 겹치지 않는다.

따라서 세 경우를 대처

1. 전혀 포함되지 않는 경우
2. 범위에 포함되는 경우
3. 둘 다 아닌 경우(depth 나눠서 들어가기)



```c++
int query(vector<int> &tree, int node, int start, int end, int i, int j){
  if (i > end || j < start) return -1; // 전혀 겹치지 않는 경우
  if (i <= start && end <= j) return tree[node]; // 구하고자 하는 범위에 해당 노드 범위가 포함되는 경우
  int m1 = query(tree, 2*node, start, (start+end)/2, i, j);
  int m2 = query(tree, 2*node+1, (start+end)/2+1, end, i, j);
  if (m1 == -1){
    return m2;
  } else if (m2 == -1) {
    return m1;
  } else {
    return min(m1, m2);
  }
}
```



### 시간복잡도

그냥 : 0 + N = MN

sqrt : N + 루트N = N + M루트N

세그 : NlogN + logN = NlogN + MlogN : 가장 빠른 방법!!



### 변경

but, 저장된 값이 변경되는 경우가 훨씬 많다. 이것을 어떻게 처리할까?

if index 3을 변경:

index 3이 포함된 범위의 노드마다, 최하단에서부터 값을 변경하면서 올라온다 => 시간복잡도 빠르다.

쿼리 코드를 조금만 바꿔주면 됨(i부터 j까지 구간을 찾는 문제에서 조금만 변경)

```c++
int query(vector<int> &tree, int node, int start, int end, int i, int j){
  if (i > end || j < start) return; // 전혀 겹치지 않는 경우
  if (i <= start && end <= j) return tree[node]; // 구하고자 하는 범위에 해당 노드 범위가 포함되는 경우
  if (start == end) {
    tree[node] = value;
    return;
  }
  update(tree, node*2, start, (start+end)/2, index, value);
  update(tree, node*2+1, (start+end)/2+1, end, index, value);
  tree[node] = min(tree[node*2], tree[node*2+1])
}
```



문제 풀다보면 분명히 맞게 풀었는데 시간초과가 날 수 있다.

그럴 때 스킬이 필요한데,

I. 예를 들어 구간 최소값이 들어가는 문제(bfs 등)

1. 시간 초과가 왜 났는지 과정을 살펴본다.
2. 시간 초과 나는 부분에서 구간 최소값을 구하고 있다.
3. 그 부분을 세그먼트 트리를 이용해서 구하는 쪽으로 바꿔본다.

따라서 그냥 짜보고 세그먼트 트리로 바꾸기 위해 분석하는 능력이 필요.



II. Heap - Heap에 들어가있는 값 중에서 최소값 찾는 것(세그먼트는 범위에 대해서 최소값)

다익스트라의 경우 해당 집합의 최소값을 구하는 작업을 반복.

세그먼트 트리는 구간이 등장하는 문제에 적용하게 된다. 구간이 등장하지 않는 문제라도 구간의 문제로 바꿔서 세그먼트를 적용할 수 있다.



## 문제 - LIS(Longest Including Subsequence)

가장 긴 증가하는 부분 수열 구하는 문제



## 가장 긴 증가하는 부분 수열 2(12015)

부분 수열 - 순서를 유지하면서 뽑아내는 것

A = {10, 20, 10, 30, 20, 50} 에서 jump해서 20, 30, 50도 해당.

여기서는 10, 20, 30, 50으로 4가 정답.

해결방법:

1. DP - O(N^2)

2. 그리디
3. 세그먼트 트리



i	10	20	10	30	20	50

A[i] 



1. DP

다이나믹의 핵심은 이기적이면 되는 것. 다른 애들이 없다고 생각한다.

i	10

D[i]   1



1) 20이 혼자 있을 때 1

i	10	20

D[i]   1	1



2) 앞에 애들이 있을 때 -> 20 앞에 있으면서 20보다 작은 수. 10이 있다. 10의 D[i]에 20을 붙이면 됨(D[i]+1)

A[i]	10	20	10	30	20	50

D[i]	 1	   2	  1	   3(=2+1) 2	4(=3+1)



N개에 대해서 앞에 있는 것 모두를 살펴봐야 함 -> O(N^2)

​	   

### 세그먼트 트리

DP와 유사하게 앞에 있는 것 중에서 작은 것을 찾는 것. but 앞에 있는 것들은 구간의 문제가 아니다. 이걸 구간의 문제로 바꿔줘야 함.



예시)

수열 {1, 3, 2, 4, 3, 4, 2}

Tree[i] = 수 i를 마지막으로 하는 가장 긴 증가하는 부분 수열(LIS)의 길이

i	1	2	3	4	5	6	7

A[i] 1	3	2	4	3	4	2



i.    	1	2	3	4	5

tree[i] 0	0	0	0	0



DP : 앞에 있는 수 중에서 **크기가 작은** 수 중에서 길이 최대값 찾기.

30보다 작은 수라면 1~29의 구간에 대해 크기가 작은 수라고 판단.



1) i=1

1에 앞에 올 수 있는 수는 없다. 그냥 1짜리 길이 수열이 탄생.

i	     1

tree[i] 1



2) i=2

A[i] = 3

1~2의구간에서 최대값을 구해본다.

i	1	2	3

tr[i] 1	0	2(=1 + 1)



3) i=3, A[i] = 2

1~1의 구간에서 최대값을 구한다.

i	1	2

tr[i] 1	2(=1+1)



4) i=4, A[i] = 4

1~3의 구간에 대해 최대값 구하기.

i	1	2	3	4

tr[i] 1	2	2	3(=2+1)



5) i=5, A[i] = 3

1~2의 구간

i 	1	2	3

tre[i] 1	2	3(=2+1)



6) i=6, A[i] = 4

1~3의 구간

i	1	2	3	4

tr[i] 1	2	3	4



logN(구간탐색)을 N개의 수에 대해 적용 -> O(NlogN)



코드는 소스 참조

### 핵심

```c++
int ans =0;
for (int i=0; i<n; i++){
  int num = Integer.valueOf(nums[i]);
  int cur = maximun(tree, 1, 1, MAX, 1, num-1);
  if (ans < cur + 1){
    ans = cur + 1;
  }
  update(tree, 1, 1, MAX, num, cur+1);
  // 생략
}
```



최소, 최대, 합, 곱 등 구한 수열의 결과 연산은 마지막에만 바꿔주면 된다. -> 세그먼트 트리로 구현 가능





## 비재귀 구현

강의할 때는 재귀함수 방식을 쓰지만, 재귀가 느려서 잘 쓰지 않는다.

재귀에서는 노드가 저장하는 구간, 인덱스를 알아야해서 3개의 값을 넣어야 했다.

비재귀에서는 그럴 일이 없음. 모든 노드를 리프로 만들어주고 트리를 채워주면 됨.

맨 밑의 트리를 N=2^k 꼴로 리프 노드를 꽉 채워준다.

full binary tree이므로 어디에 누가 있는지를 수식을 통해 구할 수 있다는 장점.



### 구간의 합 구하기

왼쪽이 왼쪽이면 || 오른쪽이 오른쪽이면 더하고 위로 이동, 

왼쪽이 오른쪽 || 오른쪽이 왼쪽이면 그 값 더하고 오른쪽으로 | 왼쪽으로 이동



### 소스 설명

b = 가장 가까운 2의 제곱꼴





## Fenwick Tree

합을 구할 때만 쓸 수 있는 트리

왼쪽 자식만 필요하다고 하면 오른쪽 자식은 지워버리는 것. -> 공간을 적게 사용

i의 마지막 1의 값: i를 2진수로 나타냈을 때, 가장 마지막 1이 나타내는 값

3 == 1**1**(2) -> 1

12 = 1**1**00(2) -> 4

num =    100110101110101**1**00000000000

~num = 011001010001010**0**11111111111

-num = 011001010001010**1**00000000000 = ~num + 1

-num을 구하면 진한 색 기준 왼쪽은 반전, 오른쪽은 0으로 채울 수 있게 됨

num & -num = 000000000000000**1**00000000000

가장 많이 쓰는 비트 연산은 Brute Force 부분집합 구하기.

그 다음 레벨에서는 이 연산이 제일 중요하다!



1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16

1	2	1	4	1	2	1	8	1	    2	   1	4	   1	   2 	1.        16

해당 수까지 몇 개의 합을 넣을 것인가가 표에 나옴. 뒤집어서 트리로 구현

​									16

​					8

​		4



A[1] + … + A[13]을 구하려면

13 = 1101(2) -> 1

tree[13] = A[13]

1~12 구하자.

12 = 1100(2) -> 4

tree[12] = A[9] + A[10] + A[11] + A[12]

1~8을 구하자.

8 = 1000(2)

tree[8] = A[1] + … + A[8]



따라서 tree[13] + tree[12] + tree[8]

1101 -> 1100 -> 1000

마지막 1을 빼가면서 그 개수만큼의 합을 더해가면 됨.



### 합 구하기 - 소스

```c++
int sum(int i){
  int ans = 0;
  while (i > 0){
    ans += tree[i];
    i -= (i & -i);
  }
  return ans;
}
```

비트 연산이라 속도가 빠르다.

합을 구하는 문제에서는 Fenwick Tree을 자주 쓰게 됨.



###변경 - 소스

```c++
int update(int i, int num){
  while(i <= n){
    tree[i] += num;
    i += (i & -i);
  }
}
```

구간이 나오고, 구간의 합을 구해야 할 때 Fenwick Tree를 쓰면 된다.



### 2D Fenwick Tree

구간이 직사각형이 되는 경우

가로로 Fenwick Tree가 있고, 세로로 Fenwick Tree가 있다.

1차원을 2차원으로 확장해서 풀면 된다.



### 배열에서 x번째 ~ y번째 합을 구하는 문제

```c++
for(int i=x; i<=y; i++){
  sum += A[i];
}
```



일차원 배열과 이차원 배열은 별로 차이 없다.

이차원 배열 : 일차원 배열의 일차원 배열.



### (x1, y1) ~ (x2, y2)의 합

```c++
for (int i = x1; i <= x2; i++){
  for(int j = y1; j <= y2; j++){
    sum += A[i][j];
  }
}
```



여기서 쓴 '배열'을 'Fenwick Tree'로 바꿔서 이해하면 됨.

이차원 트리 그림은 잊고, 일차원 트리의 일차원 트리로 이해해라.

그냥 이중 for문 구현해본다고 생각하면 됨.

3차원은 3중 for문으로 구현



```c++
void update(int x, int y, int val){
  for(int i = x; i > 0; i -= i & -i) {
    for (int j = y; j > 0; j -= j & -j){
      ans += tree[i][j];
    }
  }
  // return ans(?)
}
```



Fenwick Tree는 잘 쓸 일이 없지만 대회 준비할 때 가끔 쓰게 될 수 있어서 준비해옴.

실제로 일을 할 때 쓸 수 있는 알고리즘을 배우려면 4주가 더 필요 -> Network Flow(문제 상황을 네트워크로 만들고 최대 유량으로 보내기 - 게임 등에 필요)



## Network Flow

1. 5명이 조모임을 하려고 한다.

   사람		   역할

   A			조장

   B			자료 수집

   C			PPT

   D			발표

   E			무임승차

   A는 조장, 자료수집 / B는 자료 수집, PPT / C는 자료수집 / D는 발표, 무임승차 / E는 무임승차 하고 싶다고 함.

   1 사람은 역할 최대 1개, 1 역할도 최대 1명이 할 수 있다.

   최대한 많은 사람을 만족시키면서 역할을 배정하는 문제.

   

2. **MCMF** - 롤을 하려고 한다.

   사람 5명	  역할

   A			탑

   B			미드

   C			정글

   D			서폿

   E			바텀

   A 탑(1200), 미드(1500) / B 미드(1800), 정글(1600) / ...

   팀의 능력치의 합을 최대로 하는 문제.

   턴 방식의 게임은 이런 형태의 그래프로 만들어서 최적의 전략을 짤 수 있다.



3. 창업자

   일을 최대한 많이 시키면서 월급(합)을 최소로 주는 문제.



4. 쇼핑몰

   여러 물류창고가 있을 때, 어떤 물류창고에서 어떻게 배송해야 좋을 지 계산할 때.

   

5. 팀의 우승확률 구하기

   1위 : 84점

   2위 : 82점

   3위 : 67점

   ...

   7위 : 48점

   7위가 우승할 수 있는지 여부를 구할 때, 7위가 다 이기면서도 나머지 팀들이 1위가 되지 않게 승점을 적절히 분배해가야 하는 문제.



사실은 이걸 구현할 때 모델링(세팅)이 가장 어렵다. 





































